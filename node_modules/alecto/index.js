"use strict";

/*
Copyright (c) 2017 Ram√≥n Baas

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

/*
  Alecto Protocol

  Only tested v3 with a WS-1100

*/

const utils = require('utils');

let v1, v3, v3c;

// Calculate simple Alecto v1 CRC
// See http://www.tfd.hu/tfdhu/files/wsprotocol/auriol_protocol_v20.pdf
function calcSimpleCRC(data) {
    let th = data[9] != 1 || data[10] != 1;
    let crc = (th ? 0xf : 0x7);
    for (let i = 0; i < 8; i++) {
        let val = Number(utils.bin2dec(data.slice(4 * i, 4 * (i + 1))));
        if (th) {
            crc -= val;
        } else {
            crc += val;
        }
    }
    return (crc & 0xf);
}

// CRC calculation for Alecto v2 & v3
// Taken from https://github.com/rinie/RFSniffer/blob/master/ScanDevices.ino
function calcAlectoCRC8(data) {
  let crc = 0;
  let x = 0;
  let len = data.length;
  // Indicated changes are from reference CRC-8 function in OneWire library
  while (len--) {
    let inbyte = data[x++];
    for (let i = 0; i < 8; i++) {
      let mix = (crc ^ inbyte) & 0x80; // changed from & 0x01
      crc = (crc << 1) & 0xff; // changed from right shift
      if (mix) {
            crc ^= 0x31;// changed from 0x8C;
      }
      inbyte = (inbyte << 1) & 0xff; // changed from right shift
    }
  }
  return crc;
}

// Decode the received v1 data
function decodeAlectoV1(data) {
    let datastr = data.join('');
    let type = 'TH';
    if (datastr.slice(9, 11) === '11') {
        if (datastr.slice(12, 16) === '1100') {
            type = 'R';
        } else if (datastr.slice(12, 15) === '111' || datastr.slice(12, 24) === '100000000000') {
            type = 'W';
        }
    }
    let id = utils.bin2dec(data.slice(0, 8).reverse().join(''));
    let result = {
        id: id,
        data: {}
    }
    // Decode the data based on the type
    if (type === 'TH') {
        let temperature = data.slice(12, 24).reverse().join('');
        if (temperature[0] === '1') {
            // make it 32 bit, convert 2's complement
            temperature = ~~parseInt('11111111111111111111' + temperature, 2);
        } else {
            temperature = utils.bin2dec(temperature);
        }
        let humidity = utils.bin2dec(data.slice(28, 32).reverse().join(''))
            + utils.bin2dec(data.slice(24, 28).reverse().join(''))
        result.data.temperature = Number((temperature / 10).toFixed(1));
        result.data.humidity = Number(humidity);
        result.channel = Number(utils.bin2dec(data.slice(4, 6).reverse().join(''))) + 1;
    } else if (type === 'R') {
        let rain = utils.bin2dec(data.slice(16, 32).reverse().join(''));
        result.data.raintotal = rain * 0.25;
    } else if (type === 'W') {
        let val = utils.bin2dec(data.slice(24, 32).reverse().join('')) * 0.2;
        if (datastr.slice(12, 15) === '111') {
            result.data.direction = Number(utils.bin2dec(data.slice(15, 24).reverse().join('')));
            result.data.currentspeed = val;// gust
        } else {
            result.data.averagespeed = val;
        }
    }
    result.data.lowbattery = (data[8] === 1);
    v1.debug(result)

    return result;
}

// Decode the received v3 data
function decodeAlectoV3(data, original_length) {
  let id = utils.bin2dec(data.slice(4, 12))
  let type = data.length === 40 ? 'TH' : 'R'
  /*
     There are multiple sensors that use the same protocol and similar encoding, but are
     slightly different:
     - Alecto WS-1100/WS-1200: has no sign bit; temperature value is 40 deg higher; has low battery bit (12)
     - Fine Offset WH2(A): has sign bit (12); has no low battery status
  */
  let result
  let temperature = utils.bin2dec(data.slice(13, 24)) / 10
  let humidity = Number(utils.bin2dec(data.slice(24, 32)))
  let sensor = (type === 'TH' ? 'WS-1100' : 'WS-1200')
  let FineOffset = original_length === 42
  if (type === 'TH') {
    if (humidity === 255) {
      FineOffset = true
      type = 'T'
    } else {
      // Note: not ideal to check the temperature value to see if it is FineOffset or not (bit 14)
      FineOffset = FineOffset || (data[11] === '1' && data[14] === '0')
    }
  }
  if (FineOffset) {
    let sign = (data[12] === '1' ? -1 : 1);
    result = {
      id: id,
      channel: Number(utils.bin2dec(data.slice(5, 8))) + 1,
      name: 'WH2',
      data: { temperature: Number((sign * temperature).toFixed(1)) }
    }
    if (data.slice(9, 12) !== '111' && type !== 'T') {
      delete result.channel
      result.name = 'WH2A'
    }
    if (type === 'TH') {
      result.data.humidity = humidity
    }
  } else {
    // Alecto
    result = {
      id: id,
      channel: Number(utils.bin2dec(data.slice(2, 4))) + 1,
      name: sensor,
      data: { temperature: Number((-40 + temperature).toFixed(1)) }
    }
    if (type === 'TH') {
      result.data.humidity = humidity
    } else { // Rain sensor (WS-1200)
      let rain = utils.bin2dec(data.slice(32, 40)) * 256 + utils.bin2dec(data.slice(24, 32));
      result.data.rainrate = rain * 0.3
    }
    result.data.lowbattery = data[12] === '1'
  }

  return result;
}

function decodeAlectoWS1050(data) {
    let temperature = data.slice(16, 28);
    if (temperature[0] === '1') {
        // make it 32 bit, convert 2's complement
        temperature = ~~parseInt('11111111111111111111' + temperature, 2);
    } else {
        temperature = utils.bin2dec(temperature);
    }

    let result = {
        id: utils.bin2dec(data.slice(4, 12)),
        name: 'WS-1050',
        channel: Number(utils.bin2dec(data.slice(14, 16))) + 1,
        data: {
            temperature: Number((temperature / 10).toFixed(1)),
            button: data[13] === '1',
            lowbattery: data[12] === '1'
        }
    }
    v1.debug('WS-1050', result)

    return result;
}

// Parse the data according to the Alecto v1 protocol
var parseAlectoV1 = function(payLoad) {
    let result = 'Not a valid Alecto message';
    let data = Array.prototype.slice.call(payLoad, 0);
    let dataStr = data.join('');
    if (dataStr.slice(0, 4) === '1001' && dataStr.slice(28, 37) === '110011000') {
        // We've found a WS-1050 outdoor sensor
        result = decodeAlectoWS1050(dataStr);
    } else {
        let decVal = '';
        for (let i = 0; i < data.length; i += 4) {
            decVal += (data.slice(i, i + 4)).reverse().join('');
        }
        let crc = calcSimpleCRC(decVal);
        let check = Number(utils.bin2dec(decVal.slice(32, 36)));
        if (crc === check) {
            result = decodeAlectoV1(data);
        } else {
            result = 'CRC error for Alecto v1 (' + crc + ' vs ' + check + ')';
        }
    }

    return result;
}

// Parse the data according to the Alecto v3 protocol
var parseAlectoV3 = function(payLoad) {
  let result = 'Not a valid message';
  let payload_length = payLoad.length;
  let data = Array.prototype.slice.call(payLoad, 0);
  if (data.length % 4 !== 0) {
    data = data.splice(data.length % 4)
  }
  let decVal = data.join('');
  let len = data.length;
	let crcVals = [];
	for (let i = 0; i < (len >> 3) - 1; i++) {
		crcVals[i] = Number(utils.bin2dec(decVal.slice(8 * i, 8 * (i + 1))));
	}
	let crc = calcAlectoCRC8(crcVals);
	let check = Number(utils.bin2dec(decVal.slice(len - 8, len)));
	if (crc === check) {
		result = decodeAlectoV3(decVal, payload_length);
	} else {
		result = 'CRC error (' + crc + ' vs ' + check + ')';
	}
    return result;
}

module.exports = {
    init: () => {
        v1 = new utils.WeatherSignal({
            id: 'alectov1',
            name: 'Alecto v1',
            hint: {
                en: 'Support Alecto v1 sensors',
                nl: 'Ondersteunt Alecto v1 sensoren',
            },
            signal: 'AlectoV1',
            freq: 433,
            parser: parseAlectoV1
        });
        v3 = new utils.WeatherSignal({
            id: 'alectov3',
            name: 'Alecto v3',
            hint: {
                en: 'Supports Alecto WS-1100 & WS-1200 and Fine Offset WH2(A)',
                nl: 'Ondersteunt Alecto WS-1100/WS-1200 en Fine Offset WH2(A)'
            },
            signal: 'AlectoV3',
            freq: 433,
            parser: parseAlectoV3
        });
        v3c = new utils.WeatherSignal({
            id: 'conrad3',
            name: 'Conrad 868',
            hint: {
                en: 'Supports Conrad 868 MHz sensors',
                nl: 'Ondersteunt Conrad 868 MHz sensoren'
            },
            signal: 'Conrad',
            freq: 868,
            parser: parseAlectoV3
        });
    }
};
